# 计算机中整数为什么以「补码」的形式存储？

<!--——理解补码的正确姿势（可能是目前为止最好的理解补码的文章）-->
<!--注：本文将会以一问一答的形式一步步揭开补码的层层面纱-->

## 1.引子
如果让一个只了解二进制但不太了解计算机的人来设计有符号整数的存储形式，会怎么设计？
他可能会这样想：对于无符号整数的存储，直接使用二进制本身就够了，如果还要表示符号，就再加一个二进制位来表示。也就是符号位加上真值的绝对值, 用第一位表示符号, 其余位表示值。比如假设用8位二进制位进行存储，且符号位0表示正1表示负，那么`1`可以存储成`0000 0001`，`-1`可以存储成`1000 0001`。
这种方式非常自然，计算机中还给这种表示方式起了一个专门的名字：**「原码」**。

那计算机中是不是用原码的方式存储整数呢？很可惜，不是，它使用一种叫**「补码」**的东西来存储整数。

---

你知道计算机中以什么形式存储整数吗？是符号位加值位吗？值位是按照正常的二进制方式存储吗？

如果后两个问题你都回答是，那就意味着当用3位二进制进行存储、且符号位0表示正1表示负时，1会存储成`001`，-1会存储成`101`。可惜事实不是这样，计算机中是用补码的形式而不是刚刚那种看上去很自然的形式存储整数，补码虽然也是用符号位加值位来表示，但表示的规则不太一样：1会存成`001`，-1会存成`111`。

如果三个问题你都回答对了，你知道计算机中整数以补码的形式存储，但你知道为什么要用这种形式吗？以及**「正数的补码等于原码；负数的补码等于反码加1，而反码等于原码符号位不变，其余各位取反」**这样定义的**补码**到底意味着什么？*（假设你不知道，请接着往下看吧 XD）*

先看使用补码的目的，然后忘掉上面那个补码定义，跟我从这个目的开始，一步步探索补码的本质。
目的：为了简化计算机基本运算电路，使加减法都只需要通过加法电路实现，也就是让**减去一个正数或加上一个负数**这样的运算可以用**加上一个正数**来代替。于是改变负数存储的形式，存储成一种可以直接当成正数来相加的形式，这种形式就是补码。*（正数不用变，所以接下来的讨论中一般略去正数）*

## 2.补码是怎么把减法变成加法的？

### 2.1.用时钟理解减法变加法

这是一个身边的例子，当你校对时钟的时候，假设发现钟是6点，但实际上现在才2点，也就是它走快了4个小时，你可以有两种方法进行校正，一种是逆时针拨回4个小时到2点，另一种是顺时针拨6个小时到12点然后再拨2小时，也就是顺时针拨8个小时到2点。所以对于时钟的表盘来说，设`-N`表示逆时针拨N个小时，`N`表示顺时针拨动N个小时，那么`-4 = +8`，同样还会有 `-1 = +11`、`-5 = +7`，甚至也可以 `-4 = +8 = +20 = +32 = -16`...

这里边隐藏了什么规律？其实在数学中，`-4、+8、+20、+32、-16`可以归为符合某个条件的同一类数字 —— **对于模12同余**。
> 中文维基上对于模和同余的定义是：两个整数a、b，若它们除以正整数m所得的余数相等，则称a、b对于模m同余。

而在一个可溢出计数系统中，把计数系统容量作为模，那么所有对此模同余的数在此计数系统中都会有同样的表示，而且运算等价。
比如上面例子中的时钟表盘就是一个可溢出计数系统，模为12，所以`-4、+8、+20、+32、-16`这些对模12同余的数在时钟表盘上的表示是一样的，而且对时针做这些操作的结果也是一样的，都会拨到同样的位置。

一个n位二进制构成的计数系统，因为会舍弃溢出的高位，所以也是一个可溢出的计数系统，它的模为$2^n$ 。*（从0数到$2^n -1$，再多就溢出）*
由此可以推理，在一个3位二进制构成的模为8的计数系统中，`-2，-10，6，14`可以用同样的二进制数来表示，同时减10和加14会得到一样的结果。

### 2.2.引出 _补码_

所以，只要 _补码_ 是一个负数的正同余数，那么就能实现**加这个正同余补码跟加另一个负数是一样结果**的效果。对一个负数来说，有无数个正同余数满足条件，为了减少不必要的运算，可以规定补码就取其中最小的正数。

<!--而且如果负得太多，补一个模都不是正数，那其实算是左边越界溢出-->

> 可能因为通过原码求 _补码_ 是一个补模运算，所以它被称为 _补码_ 。

注意：这里的 _补码_ 都被我用特殊标识，因为这还不是计算机里真正的存储的补码形式，它应该叫补数，不过相信我，已经很接近了

## 3.完善 _补码_ 

### 3.1.这种 _补码_ 表示还有点问题

通过转换成 _补码_ ，减一个数确实变成加一个数了，看似很不错，但却有一个明显的问题，那就是数本身的符号丢失了。
比如3位二进制，正常表示`0~7`，使用补码法它能代替`-8~-1`的运算，但它不能真正表示`-8~-1`，因为你不知道它到底是正数还是负数。
我们把负数转换成了一种在运算中更让计算机喜欢的形式，但它却丢失了自己本身作为数的信息。

怎么解决这个问题，可能有人很快就拍脑袋：那就加一位来表示正负得了。但这样的话运算时怎么办，从第二位开始算么？那进位去位的时候是不是也需要特别注意一下不要影响到符号位？你会发现这个问题并不是那么简单。

### 3.2.怎么完善 _补码_ 

不知道大牛是怎么想到的，问题解决得非常完美：

- 在保持补码特性的前提下 *（也就是减一个数还是照样变成加一个数）*
- 增加正负的表示 *（能真正表示`-8~-1`了，只用看符号位是0还是1）*
- **还能让运算时不用另外区分符号位，直接把符号位当成值位进行运算，而结果的正负号自然会符合这个正负表示法（也就是符号位的进位和值位的进位都会自然地合理）**

而且解决方式真的皮，简单到出人意料，就是前面你拍脑袋想到的办法：**加一位来表示正负**。
**具体做法是**：在左侧高位增加一个符号位，这个符号位连同前面我们推演出的 _伪补码_ 一同构成真正完善的**补码**。
**实现的效果**：通过读取符号位能得知数的正负，同时符号位在加法运算中跟值位一样参与运算、进位、退位。

## 4.最后

总结一下

- **使用补码的目的**：简化计算机基本运算电路，使加减法都只需要用加法电路实现，用加法替代减法。
- **补码为什么能达到这个目的**：n位二进制可以构成一个可溢出计数系统，在这样的系统中，把计数系统容量作为模，所有对此模同余的数在此计数系统中都会有同样的表示，而且运算等价。而补码就是负数的最小正同余数，所以加一个负数和减一个正数都可以用加一个补码来表示。
- **怎么计算补码**：正数的补码是它本身；对负数求最小正同余数（模为值位的容量）放入值位，符号位置为1，得到负数的补码。

到这里「整数为什么以补码的形式存储」这个问题基本就解答清楚了，你会发现里边都没有反码的影子，对，就是这样，用反码以及教材里那套计算补码的方法来理解补码都是缘木求鱼，那它们是用来干什么的？值位取反加一这种算法是怎么冒出来的？[（求补码的简便算法）](http://blog.csdn.net/woodpeck/article/details/77747242) 以及大牛对补码的完善为什么可行？[（补码正确性的证明）](http://blog.csdn.net/woodpeck/article/details/77747265) 感兴趣的同学可以点击超链接继续看补充内容。



***

用映射的方式来理解也很方便

然后提出运算问题的时候可以更清晰一些

需要引入原码。

原，反，补
0000，0000
1000，1111，0000

1001，1110，1111
1111，1000，1001
0111，0111

-8，0，1000

